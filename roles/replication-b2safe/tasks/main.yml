---
# --------------------------------------------------------------------------------
# Pasting Janos description below, for reference ...
#
# (From
# https://projects.bils.se/projects/eudat-elixir-pilot-proteomics-data/wiki/Documentation_B2SAFE_setup_with_iRODS_403_from_Janos_2015-04-01 )
#
# Note though that many of these steps are already implemented in the b2safe, and
# the replication roles.
# --------------------------------------------------------------------------------
#
# A directory is required for the replicate scripts. Users access this directory via group write privileges.
#
#  imkdir /bilsZone/replicate
#  iadmin mkgroup replicate
#  ichmod -r read replicate /bilsZone/replicate
#  ichmod -r write replicate /bilsZone/replicate
#  ichmod -r inherit /bilsZone/replicate
#  iadmin atg replicate user
#
#  # TODO: In the ansible config, we didn't use a group for the access, only user ACL:s directly.
#          We might change this to use a group, like Janos did above.
#
# As it was found out it is necessary for the users to have 'own' right on the replicate directory.
#
#  ichown -r own user /bilsZone/replicate
#
#  # TODO: This needs to be implemented as well
#
#
# Set variables in rule file reConfigs/local.re. For getEpicApiParameters:
#
#  *credStoreType="os";
#  *credStorePath="/var/lib/irods/b2safe/credentials";
#  *serverID="bils-irods.nsc.liu.se:1248";
#
#  # TODO: Seems like this is not implemented?! (bit strange ...)
#
# Edit the server config file server.config and make sure it contains:
#
# The ruleset added by Jani, bils.re:
#
# #
# acPostProcForModifyDataObjMeta {
#         ON($objPath like "\*.replicate") {
#                 processReplicationCommandFile($objPath);
#         }
# }
# #
# acPostProcForModifyDataObjMeta {
#         ON($objPath like "\*.pid.create") {
#                 processPIDCommandFile($objPath);
#         }
# }
# #
# In core.re have the default resource set like:
#
# acPostProcForDataObjRead(*ReadBuffer) {
#      if (*cmd != "authZmanager.py") {
#          EUDATAuthZ("$userNameClient#$rodsZoneClient", *cmd, *args, *response);
#      }
#  }
# We had a problem with acPostProcForPut so that was not used as it was originally intended.
#
# # TODO: This doesn't seem to be implemented either (only acPostProcForPut, in euhooks.eu)
#
# Test like:
#
#  /var/lib/irods/src/B2SAFE-core-release-3.0/cmd/epicclient.py os /var/lib/irods/b2safe/credentials
#
# Jani implemented a workaround for the iRODS bug, the following rule. It is in /var/lib/irods/b2safe/EUDATUpdateParentPids.r:
#
# #
# # Updates parent pids by querying .pid.update command files and passing them to processPIDCommandFile.
# # Limits the number of processed command files per one rule run. By default, at most *MaxSuccess
# # command files are processed.
# #
# # Required rulebases: eudat, catchError
# #
# # Configuration: edit the *Coll INPUT parameter to match the local zone name and the command file collection.
# #
# # Arguments:
# #   *Coll          [INPUT]    The path to the .pid.update files
# #   *Suffix        [INPUT]    The suffix of the update files
# #
# # Author: Jani Heikkinen, CSC
# #
# update_parent_pid {
#         *ContInxOld = 1;
#         *SuccessCount = 0;
#         *FailedCount = 0;
#         *MaxSuccess = 100;
#         *Condition=&quot;COLL_NAME = '*Coll' AND DATA_NAME like '*Suffix'&quot;;
#         msiMakeGenQuery(&quot;COLL_NAME,DATA_NAME&quot;,*Condition,*GenQInp);
#         msiExecGenQuery(*GenQInp, *GenQOut);
#         msiGetContInxFromGenQueryOut(*GenQOut,*ContInxNew);
#         while(*ContInxOld &gt; 0) {
#                 if(*ContInxNew == 0) { *ContInxOld = 0; }
#                 foreach(*GenQOut) {
#                         msiGetValByKey(*GenQOut, &quot;COLL_NAME&quot;, *Cname);
#                         msiGetValByKey(*GenQOut, &quot;DATA_NAME&quot;, *Dname);
#                         *CF=&quot;*Cname/*Dname&quot;;
#                         if(errorcode(msiObjStat(*CF,*out)) &gt;= 0) {
#                                 processPIDCommandFile(*CF);
#                                 *SuccessCount = *SuccessCount + 1;
#                         } else {
#                                 logInfo(&quot;*file does not exist&quot;);
#                                 EUDATProcessErrorUpdatePID(*CF);
#                                 *FailedCount = *FailedCount + 1;
#                         }
#                 }
#                 *ContInxOld = *ContInxNew;
#                 if(*SuccessCount &gt; *MaxSuccess) { *ContInxOld = 0; }
#                 if(*ContInxOld &gt; 0) {msiGetMoreRows(*GenQInp,*GenQOut,*ContInxNew);}
#         }
#         logInfo(&quot;Updated parent PIDs: *SuccessCount . Failed updates: *FailedCount&quot;);
# }
# INPUT *Coll = &quot;/ebi/replicate&quot;, *Suffix=&quot;%%.pid.update&quot;
# OUTPUT ruleExecOut
#
# # TODO: This rule is now created as a file
- name: Add EUDATUpdateParentPids.r to b2safe rules folder
  copy: src=EUDATUpdateParentPids.r dest={{ b2safe_root }}/rules
  sudo: true
#
# Run this manually to do the replication.
#
# A crontab entry defined like:
#
# 0,10,20,30,40,50 * * * * /usr/bin/irule -F /var/lib/irods/b2safe/EUDATUpdateParentPids.r &gt;/var/tmp/EUDATUpdateParentPids.log 2&gt;&amp;1
# Further testing/changes were done by other members of the project. For example, control files manually were copied into the replication directory etc., I didn't touch those details.
#
# # TODO: This needs to be added as well.
# --------------------------------------------------------------------------------
